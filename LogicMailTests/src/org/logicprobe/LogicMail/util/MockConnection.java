/*
 * This source code was generated by HammockMaker.
 * It should be used with the Hammock libraries for the
 * CLDC 1.1 configuration.
 */
package org.logicprobe.LogicMail.util;

import com.hammingweight.hammock.*;

public class MockConnection extends org.logicprobe.LogicMail.util.Connection implements IMockObject {

    private IInvocationHandler handler;

    // Methods defined in IMockObject.
    public final void setInvocationHandler(IInvocationHandler handler) {
        if (handler == null) {
            throw new NullPointerException();
        }

        this.handler = handler;
    }

    public final IInvocationHandler getInvocationHandler() {
        if (this.handler == null) {
            setInvocationHandler(new Hamspy());
        }
        return this.handler;
    }

    // Overridden methods.
    public static final MockMethod MTHD_AVAILABLE = new MockMethod(
        MockConnection.class, 
        "MTHD_AVAILABLE",
        new Class[]{},
        new Class[]{java.io.IOException.class},
        Integer.class,
        false);
    public int available() throws java.io.IOException {
        try {
            Object[] args = new Object[0];
            MethodInvocation mi = new MethodInvocation(MTHD_AVAILABLE, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                Object retVal = mi.getReturnValue();
                AMockObject.assertReturnNotNull(MTHD_AVAILABLE, retVal);
                return ((Integer)retVal).intValue();
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            if (t instanceof java.io.IOException) { throw (java.io.IOException)t; }
            throw new HammockException(t);
        }
        return super.available();
    }

    public static final MockMethod MTHD_CLOSE = new MockMethod(
        MockConnection.class, 
        "MTHD_CLOSE",
        new Class[]{},
        new Class[]{},
        null,
        false);
    public void close()  {
        try {
            Object[] args = new Object[0];
            MethodInvocation mi = new MethodInvocation(MTHD_CLOSE, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                mi.getReturnValue();
                return;
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            throw new HammockException(t);
        }
        super.close();
    }

    public static final MockMethod MTHD_ENABLE_COMPRESSION = new MockMethod(
        MockConnection.class, 
        "MTHD_ENABLE_COMPRESSION",
        new Class[]{},
        new Class[]{},
        null,
        false);
    public void enableCompression()  {
        try {
            Object[] args = new Object[0];
            MethodInvocation mi = new MethodInvocation(MTHD_ENABLE_COMPRESSION, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                mi.getReturnValue();
                return;
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            throw new HammockException(t);
        }
        super.enableCompression();
    }

    public static final MockMethod MTHD_FORCE_CLOSE = new MockMethod(
        MockConnection.class, 
        "MTHD_FORCE_CLOSE",
        new Class[]{},
        new Class[]{},
        null,
        false);
    public void forceClose()  {
        try {
            Object[] args = new Object[0];
            MethodInvocation mi = new MethodInvocation(MTHD_FORCE_CLOSE, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                mi.getReturnValue();
                return;
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            throw new HammockException(t);
        }
        super.forceClose();
    }

    public static final MockMethod MTHD_GET_BYTES_RECEIVED = new MockMethod(
        MockConnection.class, 
        "MTHD_GET_BYTES_RECEIVED",
        new Class[]{},
        new Class[]{},
        Integer.class,
        false);
    public int getBytesReceived()  {
        try {
            Object[] args = new Object[0];
            MethodInvocation mi = new MethodInvocation(MTHD_GET_BYTES_RECEIVED, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                Object retVal = mi.getReturnValue();
                AMockObject.assertReturnNotNull(MTHD_GET_BYTES_RECEIVED, retVal);
                return ((Integer)retVal).intValue();
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            throw new HammockException(t);
        }
        return super.getBytesReceived();
    }

    public static final MockMethod MTHD_GET_BYTES_SENT = new MockMethod(
        MockConnection.class, 
        "MTHD_GET_BYTES_SENT",
        new Class[]{},
        new Class[]{},
        Integer.class,
        false);
    public int getBytesSent()  {
        try {
            Object[] args = new Object[0];
            MethodInvocation mi = new MethodInvocation(MTHD_GET_BYTES_SENT, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                Object retVal = mi.getReturnValue();
                AMockObject.assertReturnNotNull(MTHD_GET_BYTES_SENT, retVal);
                return ((Integer)retVal).intValue();
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            throw new HammockException(t);
        }
        return super.getBytesSent();
    }

    public static final MockMethod MTHD_GET_CONNECTION_TYPE = new MockMethod(
        MockConnection.class, 
        "MTHD_GET_CONNECTION_TYPE",
        new Class[]{},
        new Class[]{},
        Integer.class,
        false);
    public int getConnectionType()  {
        try {
            Object[] args = new Object[0];
            MethodInvocation mi = new MethodInvocation(MTHD_GET_CONNECTION_TYPE, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                Object retVal = mi.getReturnValue();
                AMockObject.assertReturnNotNull(MTHD_GET_CONNECTION_TYPE, retVal);
                return ((Integer)retVal).intValue();
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            throw new HammockException(t);
        }
        return super.getConnectionType();
    }

    public static final MockMethod MTHD_GET_LOCAL_ADDRESS = new MockMethod(
        MockConnection.class, 
        "MTHD_GET_LOCAL_ADDRESS",
        new Class[]{},
        new Class[]{},
        java.lang.String.class,
        false);
    public java.lang.String getLocalAddress()  {
        try {
            Object[] args = new Object[0];
            MethodInvocation mi = new MethodInvocation(MTHD_GET_LOCAL_ADDRESS, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                Object retVal = mi.getReturnValue();
                return (java.lang.String)retVal;
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            throw new HammockException(t);
        }
        return super.getLocalAddress();
    }

    public static final MockMethod MTHD_IS_CONNECTED = new MockMethod(
        MockConnection.class, 
        "MTHD_IS_CONNECTED",
        new Class[]{},
        new Class[]{},
        Boolean.class,
        false);
    public boolean isConnected()  {
        try {
            Object[] args = new Object[0];
            MethodInvocation mi = new MethodInvocation(MTHD_IS_CONNECTED, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                Object retVal = mi.getReturnValue();
                AMockObject.assertReturnNotNull(MTHD_IS_CONNECTED, retVal);
                return ((Boolean)retVal).booleanValue();
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            throw new HammockException(t);
        }
        return super.isConnected();
    }

    public static final MockMethod MTHD_RECEIVE = new MockMethod(
        MockConnection.class, 
        "MTHD_RECEIVE",
        new Class[]{},
        new Class[]{java.io.IOException.class},
        byte[].class,
        false);
    public byte[] receive() throws java.io.IOException {
        try {
            Object[] args = new Object[0];
            MethodInvocation mi = new MethodInvocation(MTHD_RECEIVE, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                Object retVal = mi.getReturnValue();
                return (byte[])retVal;
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            if (t instanceof java.io.IOException) { throw (java.io.IOException)t; }
            throw new HammockException(t);
        }
        return super.receive();
    }

    public static final MockMethod MTHD_RECEIVE_$_CONNECTIONRESPONSETESTER = new MockMethod(
        MockConnection.class, 
        "MTHD_RECEIVE_$_CONNECTIONRESPONSETESTER",
        new Class[]{org.logicprobe.LogicMail.util.ConnectionResponseTester.class},
        new Class[]{java.io.IOException.class},
        byte[].class,
        false);
    public byte[] receive(org.logicprobe.LogicMail.util.ConnectionResponseTester arg0) throws java.io.IOException {
        try {
            Object[] args = new Object[1];
            args[0] = arg0;
            MethodInvocation mi = new MethodInvocation(MTHD_RECEIVE_$_CONNECTIONRESPONSETESTER, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                Object retVal = mi.getReturnValue();
                return (byte[])retVal;
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            if (t instanceof java.io.IOException) { throw (java.io.IOException)t; }
            throw new HammockException(t);
        }
        return super.receive(arg0);
    }

    public static final MockMethod MTHD_SEND_COMMAND_$_STRING = new MockMethod(
        MockConnection.class, 
        "MTHD_SEND_COMMAND_$_STRING",
        new Class[]{java.lang.String.class},
        new Class[]{java.io.IOException.class},
        null,
        false);
    public void sendCommand(java.lang.String arg0) throws java.io.IOException {
        try {
            Object[] args = new Object[1];
            args[0] = arg0;
            MethodInvocation mi = new MethodInvocation(MTHD_SEND_COMMAND_$_STRING, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                mi.getReturnValue();
                return;
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            if (t instanceof java.io.IOException) { throw (java.io.IOException)t; }
            throw new HammockException(t);
        }
        super.sendCommand(arg0);
    }

    public static final MockMethod MTHD_SEND_RAW_$_ARRAY_BYTE_INT_INT = new MockMethod(
        MockConnection.class, 
        "MTHD_SEND_RAW_$_ARRAY_BYTE_INT_INT",
        new Class[]{byte[].class, Integer.class, Integer.class},
        new Class[]{java.io.IOException.class},
        null,
        false);
    public void sendRaw(byte[] arg0, int arg1, int arg2) throws java.io.IOException {
        try {
            Object[] args = new Object[3];
            args[0] = arg0;
            args[1] = new Integer(arg1);
            args[2] = new Integer(arg2);
            MethodInvocation mi = new MethodInvocation(MTHD_SEND_RAW_$_ARRAY_BYTE_INT_INT, this, args);
            getInvocationHandler().invoke(mi);
            if (mi.isEvaluated()) {
                mi.getReturnValue();
                return;
            }
        } catch (Throwable t) {
            if (t instanceof java.lang.Error) { throw (java.lang.Error)t; }
            if (t instanceof java.lang.RuntimeException) { throw (java.lang.RuntimeException)t; }
            if (t instanceof java.io.IOException) { throw (java.io.IOException)t; }
            throw new HammockException(t);
        }
        super.sendRaw(arg0, arg1, arg2);
    }

    // Constructors.
    public MockConnection(javax.microedition.io.SocketConnection arg0, int arg1) throws java.io.IOException {
        super(arg0, arg1);
    }

    public MockConnection(javax.microedition.io.SocketConnection arg0, int arg1, IInvocationHandler handler) throws java.io.IOException {
        super(arg0, arg1);
        setInvocationHandler(handler);
    }

}
